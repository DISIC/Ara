// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator nestjsDto {
  provider                        = "prisma-generator-nestjs-dto"
  output                          = "../src/generated/nestjs-dto"
  outputToNestJsResourceStructure = "false"
  exportRelationModifierClasses   = "true"
  reExport                        = "false"
  createDtoPrefix                 = "Create"
  updateDtoPrefix                 = "Update"
  dtoSuffix                       = "Dto"
  entityPrefix                    = ""
  entitySuffix                    = ""
  fileNamingStyle                 = "camel"
}

model Recipent {
  id    Int    @id @default(autoincrement())
  name  String
  email String

  Audit         Audit?  @relation(fields: [auditUniqueId], references: [editUniqueId], onDelete: Cascade)
  auditUniqueId String?

  @@unique([email, auditUniqueId])
}

enum AuditType {
  FAST // 25 criteria
  COMPLEMENTARY // 50 criteria
  FULL // 106 criteria
}

model Audit {
  id Int @id @default(autoincrement())

  editUniqueId    String @unique
  consultUniqueId String @unique

  // Step 1

  initiator String

  procedureName String
  procedureUrl  String

  contactName    String?
  contactEmail   String
  contactFormUrl String

  recipients Recipent[]

  auditorName  String
  auditorEmail String

  technologies String[]

  // Step 2 (all fields must be optionnal)

  auditType    AuditType?
  auditTools   String[]
  environments TestEnvironment[]
  /// @DtoEntityHidden
  pages        AuditedPage[]

  notCompliantContent String?
  derogatedContent    String?
  notInScopeContent   String?

  auditTraceId Int        @unique
  auditTrace   AuditTrace @relation(fields: [auditTraceId], references: [id])

  // Step 4

  publicationDate DateTime?
  editionDate     DateTime?

  @@unique([editUniqueId, consultUniqueId])
}

model TestEnvironment {
  id                  Int    @id @default(autoincrement())
  platform            String
  assistiveTechnology String
  browser             String

  audit         Audit?  @relation(fields: [auditUniqueId], references: [editUniqueId], onDelete: Cascade)
  auditUniqueId String?

  @@unique([platform, assistiveTechnology, browser, auditUniqueId])
}

model AuditedPage {
  id   Int    @id @default(autoincrement())
  name String
  url  String

  audit         Audit?  @relation(fields: [auditUniqueId], references: [editUniqueId], onDelete: Cascade)
  auditUniqueId String?

  results CriterionResult[]

  @@unique([url, auditUniqueId])
}

model CriterionResult {
  id Int @id @default(autoincrement())

  status CriterionResultStatus @default(NOT_TESTED)

  compliantComment String?

  errorDescription String?
  userImpact       CriterionResultUserImpact?
  recommandation   String?

  notApplicableComment String?

  topic     Int
  criterium Int

  // Results are linked through the page url and audit unique id.
  auditUniqueId String
  pageUrl       String
  /// @DtoEntityHidden
  page          AuditedPage @relation(fields: [pageUrl, auditUniqueId], references: [url, auditUniqueId], onDelete: Cascade, onUpdate: Cascade)

  @@unique([auditUniqueId, pageUrl, topic, criterium])
}

enum CriterionResultStatus {
  COMPLIANT
  NOT_COMPLIANT
  NOT_APPLICABLE
  NOT_TESTED
}

enum CriterionResultUserImpact {
  MINOR
  MAJOR
  BLOCKING
}

model AuditTrace {
  id                   Int    @id @default(autoincrement())
  auditEditUniqueId    String @unique
  auditConsultUniqueId String @unique
  Audit                Audit?
}
